module Task3 where

{-
   Явная рекурсия в решениях хотя и допускается, но не приветствуется.
   Старайтесь обходиться стандартными функциями, используя при этом создание
   функций «на лету». Пытайтесь максимально упростить уже написанные
   решения, применяя подходящие функции из модуля Data.List и любых
   других модулей. Перед выполнением заданий изучите примеры из лекций.
-}

import Data.List

-- 1) Написать функцию, которая возвращает сумму первого и последнего элементов списка,
--    если список непуст, и 0 в противном случае.

f1 :: Num a => [a] -> a
f1 [] = 0
f1 xs = head xs + last xs

-- 2) Написать функцию, которая возвращает длину числового  списка, если в нём имеется
--    нулевой элемент, и -1 в противном случае.

f2 :: (Num a, Eq a) => [a] -> Int
f2 xs = if any ((==) 0) xs then length xs else -1

-- 3) Реализовать аналог функции replicate, воспользовавшись функциями repeat и take.
--    Рекомендация: постарайтесь воспользоваться операцией композиции.

replicate' :: Int -> a -> [a]
replicate' n a = take n (repeat a)

-- replicate' = (. repeat) . take

-- фигня какая-то

-- 4) Посчитать количество слов в заданном предложении.
--    Рекомендация: постарайтесь воспользоваться операцией композиции.

ws :: String -> Int
ws = length . words

test_ws = ws "The quick brown fox jumps over the lazy dog" == 9

{-
  5) Преобразовать данный список целых чисел следующим образом:
     a) увеличить все его элементы в два раза;
     b) увеличить все его элементы с четными значениями в два раза;
     c) обнулить все его элементы с нечетными значениями.

  Каждая функция должна быть реализована несколькими способами
  с использованием именованной функции, анонимной функции и сечений:
-}

f5a_1 = map f
  where
    f x = x * 2

f5a_2 = map (\x -> x * 2)

f5a_3 = map (*2)

f5b_1 = map f
  where
    f x = if even x then x*2 else x

f5b_2 = map (\x -> if even x then x*2 else x)

f5c_1 = map f
  where
    f x = if even x then x else 0

f5c_2 = map (\x -> if even x then x else 0)

-- 6) Удалить из целочисленного списка все элементы,
--    превосходящие заданное целое число k.

f6_1 :: Integer -> [Integer] -> [Integer]
f6_1 k = filter f
 where
   f = (>) k

f6_2 :: Integer -> [Integer] -> [Integer]
f6_2 k = filter (\x -> x > k)

f6_3 :: Integer -> [Integer] -> [Integer]
f6_3 = filter . (>)

-- 7) Найти сумму и произведение элементов числового списка.

sumprod :: Num a => [a] -> (a, a)
sumprod = foldl step (0, 1)
  where
    step (s, p) x = (s+x, p*x)

-- 8) Сформировать список, содержащий каждый второй элемент исходного.
every2nd :: [a] -> [a]
every2nd = fst . foldl step ([], False)
  where
    step (xs, True)  x = (xs ++ [x], False)
    step (xs, False) x = (xs,        True)

test_every2nd = every2nd [1,2,3,4,5] == [2,4] && every2nd [5, 10] == [10]

-- 9) Проверить, является ли заданное целое число простым.
isPrime n = foldl check True [2..n `div` 2]
  where
    check acc x = acc && (n `mod` x /= 0)

test_isPrime = isPrime 547 && isPrime 7927 && (not $ isPrime 4131)
