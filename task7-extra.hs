import Data.List

{-
 1) Формирование числовых последовательностей с помощью функции iterate.
  a) Список натуральных чисел, начиная с 0.
  b) Список положительных чётных чисел.
  c) Список элементов последовательности: a_0=1, a_n=(1+a_{n-1})/2.
  d) Список символов английского алфавита.
-}

nats :: [Integer]
nats = iterate undefined 0

evens :: [Integer]
evens = undefined

series :: [Double]
series = undefined

engAlphabet :: [Char]
engAlphabet = take 26 undefined

-- 2) Дан список. Определить длину самого длинного подсписка, содержащего
--     подряд идущие одинаковые элементы (функция group). 

longestRepeated :: Eq a => [a] -> Int
longestRepeated = undefined

{-
 3) Группировка списков.
  a) Дан список символов. Сгруппировать подряд идущие символы по принципу:
     цифры — не цифры — ...
  b) Дан список и ненулевое натуральное число n. Разбить список на подсписки
     длиной n каждый. Последний подсписок может содержать менее n элементов.
  c) Дан список и ненулевые натуральные числа n и m. Разбить список на
     перекрывающиеся подсписки длиной n элементов со сдвигом относительно
     предыдущего подсписка на m элементов.

  Совет: в решениях могут пригодиться функции group и groupBy, также
  допустимо использование явной рекурсии.
-}

f2a :: [Char] -> [[Char]]
f2a = undefined

f2b :: [a] -> Int -> [[a]]
f2b xs n = undefined

test_f2b = f2b [1..10] 4 == [[1,2,3,4],[5,6,7,8],[9,10]]

f2c :: [a] -> Int -> Int -> [[a]]
f2c xs n m = undefined

test_f2c = f2c [1..10] 4 2 == [[1,2,3,4],[3,4,5,6],[5,6,7,8],[7,8,9,10],[9,10]]

-- 4) Посчитать количество элементов списка, за которыми следуют превосходящие их элементы.

countEls :: [Integer] -> Int
countEls xs = undefined $ zipWith (<) xs (tail xs)

-- 5) Посчитать количество локальных минимумов в целочисленном списке
--  (элемент называется локальным минимумом, если он меньше всех своих соседей).

countLocMins :: [Integer] -> Int
countLocMins = undefined

-- 6) Дан список. Повторить каждый его элемент заданное число раз.
--    Совет: в решении может пригодиться функция concat.

repeatEls :: Int -> [a] -> [a]
repeatEls = undefined

test_repeatEls = repeatEls 2 [1,2,3] == [1,1,2,2,3,3]

-- 7) Найти сумму всех чисел Фибоначчи, удовлетворяющих заданному предикату,
--    в указанном промежутке (например: все чётные от 1 до 106).

condFibsSum :: (Integer -> Bool) -> Integer -> Integer -> Integer
condFibsSum pred from to = undefined

-- 8) Сформировать список строк, представляющих n-значные двоичные числа.

binNumbers :: Int -> [String]
binNumbers = undefined

test_binNumbers = binNumbers 3 == ["100", "101", "110", "111"]

