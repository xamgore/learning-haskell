-- Все функции в этом упражнении должны быть рекурсивными. Использование
-- стандартных функций обработки списков не допускается.
-- Все функции должны сопровождаться типовыми аннотациями.

-- 1) Дан список. Удалить из него все отрицательные элементы.

removeNeg :: Num a => [a] -> [a]
removeNeg = undefined

-- 2) Дан список. Увеличить элементы с чётными значениями в два раза, оставив
--    все остальные без изменений.

-- ???

-- 3) Дан список. Переставить местами первый и второй элементы,
--    третий и четвёртый, пятый и шестой, и т.д.
--    Если список имеет нечётную длину, последний элемент отбрасывается.

-- swapElts :: ???
swapElts [] = undefined
swapElts [x] = undefined
swapElts (x:y:xs) = undefined

-- 4)
-- Даны два списка целых чисел. Сформировать список, каждый элемент которого равен сумме
-- соответствующих   элементов исходных списков. Предусмотреть ситуацию списков разной длины.
combine_plus :: [Integer] -> [Integer] -> [Integer]
combine_plus [] ys = ys
combine_plus xs [] = xs
combine_plus (x:xs) (y:ys) = undefined


-- 5)
-- Даны два списка. Сформировать новый список, содержащий пары из соответствующих элементов
-- исходных списков. Хвост более длинного списка отбросить.

-- ???

-- 6) Написать функции, которые по заданному n возвращают список,
--    состоящий из n первых натуральных чисел

-- а) в порядке убывания;

nats_dec :: Integer -> [Integer]
nats_dec = undefined

-- б) в порядке возрастания.

nats_inc :: Integer -> [Integer]
nats_inc = undefined

-- 7) Дан список, найти его последний элемент.

lastElt :: [a] -> a
lastElt = undefined

-- 8) Дан элемент типа a и список [a]. Вставить между всеми элементами списка заданный элемент.
-- Например, при заданных 0 и [1,2,3] должно получиться [1,0,2,0,3].

-- ???

-- 9) Написать функцию, которая разбивает список на два подсписка: элементы из начала списка,
--    совпадающие с первым элементом, и все остальные элементы, например:
--    [1,1,1,2,3,1] -> ([1,1,1], [2,3,1]).

divide :: Eq a => [a] -> ([a], [a])
divide = undefined

-- 10) Написать функцию, которая последовательно применяет заданную функцию к двум
--     подряд идущим элементам списка, заменяя первый из них на результат применения
--     и постепенно перемещаясь к концу списка. Длина списка при этом уменьшается на 1.

slide :: (a -> a -> a) -> [a] -> [a]
slide = undefined

-- Должно быть True
test_slide = slide (+) [1,2,3,4] == [3, 5, 7] && slide (*) [1,2,3] == [2, 6]
