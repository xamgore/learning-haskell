{-
 1) Вычислить сумму всех целых чисел от a до b включительно (a<=b).
    Требуется написать два решения: рекурсивное и итеративное
    (с аккумулирующим параметром). Необходимо предусмотреть случай
    некорректных значений параметров a и b.
-}

sum_ab_rec = undefined

sum_ab_iter = undefined

-- 2) Определить рекурсивную функцию, определяющую количество чётных
--    элементов в списке.

nEven :: Integral a => [a] -> Int
nEven [] = 0
nEven (x:xs) = undefined

{-
 3) Увеличить все элементы заданного списка в два раза с помощью рекурсии.
    Указание: в решении может понадобиться операция конструирования списка
    (присоединение головы к хвосту):

   ghci> 1 : [2,3,4]
   [1,2,3,4]
-}

doubleElems :: Num a => [a] -> [a]
doubleElems = undefined

{-
 4) Дан список целых чисел. Пользуясь рекурсией, сформировать новый
    список, содержащий только нечётные элементы исходного.
    Совет: в решении может пригодиться функция odd.
-}

fltOdd :: Integral a => [a] -> [a]
fltOdd = undefined

{-
 5) Написать рекурсивную функцию repl, которая по заданному целому
    числу n и параметру произвольного типа a создаёт список длины n,
    содержащий элементы a.
-}

repl :: Int -> a -> [a]
repl 0 _ = []
repl n a = undefined

{-
 6) Написать рекурсивную функцию, которая принимает на вход функцию и список,
    применяет функцию к каждому элементу списка и возвращает список
    результатов.
-}

processList :: (a -> a) -> [a] -> [a]
processList = undefined

-- Написать вторую реализацию функции doubleElems с использованием processList
-- (левую часть определения менять нельзя)

doubleElems' = undefined

{-
 7) Написать рекурсивную функцию, которая принимает на вход предикат
    (функцию, возвращающую Bool) и список, и возвращает список,
    содержащий только удовлетворяющие предикату элементы.
-}

filterPred :: (a -> Bool) -> [a] -> [a]
filterPred = undefined

-- Написать вторую реализацию функции fltOdd с использованием filterPred
-- (левую часть определения менять нельзя)

fltOdd' = undefined
